<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="flopoco.css">
<meta charset="utf-8"> 
<title>FloPoCo user manual</title>
</head>
<body>
<h1> Operator list for FloPoCo version 4.1</h1>
<h3>Shifters, Leading Zero Counters, etc</h3>
<dl>
<dt class="operatorname">Shifter</dt>
<dd class="operatordescription">A classical barrel shifter. The output size is computed.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wIn</code>  (<code class="parametertype">int</code>) </dt><dd>input size in bits</dd>
<dt> <code class="parametername">maxShift</code>  (<code class="parametertype">int</code>) </dt><dd>maximum shift distance in bits</dd>
<dt> <code class="parametername">dir</code>  (<code class="parametertype">bool</code>) </dt><dd>0=left, 1=right</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">LZOC</dt>
<dd class="operatordescription">A classical barrel shifter. The output size is computed.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wIn</code>  (<code class="parametertype">int</code>) </dt><dd>input size in bits</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">LZOCShifterSticky</dt>
<dd class="operatordescription">A combined leading zero/one counter and shifter, useful for floating-point normalization.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wIn</code>  (<code class="parametertype">int</code>) </dt><dd>input size in bits</dd>
<dt> <code class="parametername">wOut</code>  (<code class="parametertype">int</code>) </dt><dd>output size in bits</dd>
<dt> <code class="parametername">wCount</code>  (<code class="parametertype">int</code>) </dt><dd>size in bits of the count output</dd>
<span class="optionalparam"> <dt> <code class="parametername">computeSticky</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>if false the shifted-out bits are discarded, if true they are ORed into a sticky bit which is output</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">countType</code>  (<code class="parametertype">int</code>)   (optional, default value is -1)</dt><dd>0 to count zeroes, 1 to count ones, -1 to have a dynamic OZb input that tells what to count</dd> </span>
</dl></dd>
</dl>
<h3>Basic integer operators (pipelined)</h3>
<dl>
<dt class="operatorname">IntAdder</dt>
<dd class="operatordescription">Integer adder. In modern VHDL, integer addition is expressed by a + and one usually needn't define an entity for it. However, this operator will be pipelined if the addition is too large to be performed at the target frequency.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wIn</code>  (<code class="parametertype">int</code>) </dt><dd>input size in bits</dd>
<span class="optionalparam"> <dt> <code class="parametername">arch</code>  (<code class="parametertype">int</code>)   (optional, default value is -1)</dt><dd>-1 for automatic, 0 for classical, 1 for alternative, 2 for short latency</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">optObjective</code>  (<code class="parametertype">int</code>)   (optional, default value is 2)</dt><dd>0 to optimize for logic, 1 to optimize for register, 2 to optimize for slice/ALM count</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">SRL</code>  (<code class="parametertype">bool</code>)   (optional, default value is true)</dt><dd>optimize for shift registers</dd> </span>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">IntComparator</dt>
<dd class="operatordescription">An integer comparator.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wIn</code>  (<code class="parametertype">int</code>) </dt><dd>input size in bits</dd>
<dt> <code class="parametername">criteria</code>  (<code class="parametertype">int</code>) </dt><dd>-2=lesser than, -1=lesser or equal, 0=equal, 1=greater or equal, 2=greater</dd>
<dt> <code class="parametername">constant</code>  (<code class="parametertype">bool</code>) </dt><dd></dd>
<dt> <code class="parametername">constValue</code>  (<code class="parametertype">int</code>) </dt><dd>the value to compare to</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">IntDualSub</dt>
<dd class="operatordescription">Pipelined dual adder/subtractor</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wIn</code>  (<code class="parametertype">int</code>) </dt><dd>input size in bits</dd>
<dt> <code class="parametername">opType</code>  (<code class="parametertype">int</code>) </dt><dd>1=compute X-Y and X+Y, 2=compute X-Y and Y-X</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">IntMultiplier</dt>
<dd class="operatordescription">A pipelined integer multiplier.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wX</code>  (<code class="parametertype">int</code>) </dt><dd>size of input X</dd>
<dt> <code class="parametername">wY</code>  (<code class="parametertype">int</code>) </dt><dd>size of input Y</dd>
<span class="optionalparam"> <dt> <code class="parametername">wOut</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>size of the output if you want a truncated multiplier. 0 for full multiplier</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">signedIO</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>inputs and outputs can be signed or unsigned</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">superTile</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>if true, attempts to use the DSP adders to chain sub-multipliers. This may entail lower logic consumption, but higher latency.</dd> </span>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">IntSquarer</dt>
<dd class="operatordescription">A pipelined integer squarer.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wIn</code>  (<code class="parametertype">int</code>) </dt><dd>size of input in bits</dd>
</dl></dd>
</dl>
<h3>Basic floating-point Operators</h3>
<dl>
<dt class="operatorname">FPAdd</dt>
<dd class="operatordescription">A correctly rounded floating-point adder.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
<span class="optionalparam"> <dt> <code class="parametername">sub</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>implement a floating-point subtractor instead of an adder</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">dualPath</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>use a dual-path algorithm, more expensive but shorter latency</dd> </span>
</dl></dd>
<dd>Single-path is lower hardware, longer latency than dual-path.<br> The difference between single-path and dual-path is well explained in textbooks such as Ercegovac and Lang's <em>Digital Arithmetic</em>, or Muller et al's <em>Handbook of floating-point arithmetic.</em></dd>
</dl>
<dl>
<dt class="operatorname">FPAddSub</dt>
<dd class="operatordescription">A fused floating-point adder and subtracter, computes both a+b and a-b.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">FPAddDualPath</dt>
<dd class="operatordescription">Floating-point adder with dual-path architecture. Trades a larger circuit size for a smaller latency.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">FPAdd3Input</dt>
<dd class="operatordescription">A 3-operand floating-point adder.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">FPAddSinglePath</dt>
<dd class="operatordescription">A floating-point adder with a new, more compact single-path architecture.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">FPAddSinglePathIEEE</dt>
<dd class="operatordescription">A floating-point adder with a new, more compact single-path architecture.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">FPMult</dt>
<dd class="operatordescription">A floating-point multiplier. The actual FloPoCo component supports different input and output sizes, but this is not available from the command line.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>input's mantissa size in bits</dd>
<span class="optionalparam"> <dt> <code class="parametername">wFout</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>output's mantissa size in bits (if 0 or ommitted, will be equal to wFIn)</dd> </span>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">FPSquare</dt>
<dd class="operatordescription">A floating-point squarer, using IntSquarer for the mantissa.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF_in</code>  (<code class="parametertype">int</code>) </dt><dd>input's mantissa size in bits</dd>
<dt> <code class="parametername">wF_out</code>  (<code class="parametertype">int</code>) </dt><dd>output's mantissa size in bits</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">FPDiv</dt>
<dd class="operatordescription">A correctly rounded floating-point division.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
<span class="optionalparam"> <dt> <code class="parametername">radix</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>Can be 0, 4 or 8. Default 0 means: let FloPoCo choose between 4 and 8. In your context, the other choice may have a better area/speed trade-offs</dd> </span>
</dl></dd>
<dd>The algorithm used here is the division by digit recurrence (SRT). In radix 4, we use a maximally redundant digit set. In radix 8, we use split-digits in [-10,10], and a bit of prescaling.</dd>
</dl>
<dl>
<dt class="operatorname">FPSqrt</dt>
<dd class="operatordescription">A correctly rounded floating-point square root function.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
</dl></dd>
</dl>
<h3>Multipliers and dividers by constants</h3>
<dl>
<dt class="operatorname">FPConstMult</dt>
<dd class="operatordescription">Floating-point constant multiplier using the shift-and-add approach.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE_in</code>  (<code class="parametertype">int</code>) </dt><dd>input exponent width</dd>
<dt> <code class="parametername">wF_in</code>  (<code class="parametertype">int</code>) </dt><dd>input significand part width</dd>
<dt> <code class="parametername">wE_out</code>  (<code class="parametertype">int</code>) </dt><dd>output exponent width</dd>
<dt> <code class="parametername">wF_out</code>  (<code class="parametertype">int</code>) </dt><dd>output significand width</dd>
<dt> <code class="parametername">constant</code>  (<code class="parametertype">string</code>) </dt><dd>constant in sollya formalism (e.g. "cos(3*pi/2)" or "13176795b-22")</dd>
<span class="optionalparam"> <dt> <code class="parametername">cst_width</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>constant precision. If set to zero, the actual width will be computed in order to get a faithful result.</dd> </span>
</dl></dd>
<dd>An early version of the technique used is described in  <a href="bib/flopoco.html#BrisebarreMullerDinechin2008:ASAP">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FPConstMultRational</dt>
<dd class="operatordescription">Correctly rounded floating-point multiplier by a rational constant.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE_in</code>  (<code class="parametertype">int</code>) </dt><dd>input exponent width</dd>
<dt> <code class="parametername">wF_in</code>  (<code class="parametertype">int</code>) </dt><dd>input significand part width</dd>
<dt> <code class="parametername">wE_out</code>  (<code class="parametertype">int</code>) </dt><dd>output exponent width</dd>
<dt> <code class="parametername">wF_out</code>  (<code class="parametertype">int</code>) </dt><dd>output significand width</dd>
<dt> <code class="parametername">a</code>  (<code class="parametertype">int</code>) </dt><dd>numerator</dd>
<dt> <code class="parametername">b</code>  (<code class="parametertype">int</code>) </dt><dd>denominator</dd>
</dl></dd>
<dd>The technique used is described in  <a href="bib/flopoco.html#Dinechin2012-TCASII">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FPRealKCM</dt>
<dd class="operatordescription">Table based real multiplier for floating points input. </dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent width</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>significand width</dd>
<dt> <code class="parametername">constant</code>  (<code class="parametertype">string</code>) </dt><dd>constant given in arbitrary-precision decimal, or as a Sollya expression, e.g "log(2)"</dd>
</dl></dd>
<dd>KCM is a table-based method well suited to LUT-based FPGAs. It is due to Ken Chapman who published it in 1994.</dd>
</dl>
<dl>
<dt class="operatorname">IntConstDiv</dt>
<dd class="operatordescription">Integer divider by a small constant.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wIn</code>  (<code class="parametertype">int</code>) </dt><dd>input size in bits</dd>
<dt> <code class="parametername">d</code>  (<code class="parametertype">int</code>) </dt><dd>small integer to divide by</dd>
<span class="optionalparam"> <dt> <code class="parametername">arch</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>architecture used -- 0 for linear-time, 1 for log-time</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">remainderOnly</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>if true, the architecture doesn't output the quotient</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">alpha</code>  (<code class="parametertype">int</code>)   (optional, default value is -1)</dt><dd>Algorithm uses radix 2^alpha. -1 choses a sensible default.</dd> </span>
</dl></dd>
<dd>This operator is described, for arch=0, in <a href="bib/flopoco.html#dedinechin:2012:ensl-00642145:1">this article</a>, and for arch=1, in <a href="bib/flopoco.html#UgurdagEtAl2016">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FPConstDiv</dt>
<dd class="operatordescription">Correctly rounded floating-point divider by a small constant.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
<dt> <code class="parametername">d</code>  (<code class="parametertype">int</code>) </dt><dd>small integer to divide by</dd>
<span class="optionalparam"> <dt> <code class="parametername">dExp</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>binary exponent of d (the operator will divide by d.2^dExp)</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">alpha</code>  (<code class="parametertype">int</code>)   (optional, default value is -1)</dt><dd>Algorithm uses radix 2^alpha. -1 choses a sensible default.</dd> </span>
</dl></dd>
<dd>Correct rounding to the nearest (if you want other rounding modes contact us). This operator is described in <a href="bib/flopoco.html#dedinechin:2012:ensl-00642145:1">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FixRealKCM</dt>
<dd class="operatordescription">Table based real multiplier. Output size is computed</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">signedInput</code>  (<code class="parametertype">bool</code>) </dt><dd>0=unsigned, 1=signed</dd>
<dt> <code class="parametername">msbIn</code>  (<code class="parametertype">int</code>) </dt><dd>weight associated to most significant bit (including sign bit)</dd>
<dt> <code class="parametername">lsbIn</code>  (<code class="parametertype">int</code>) </dt><dd>weight associated to least significant bit</dd>
<dt> <code class="parametername">lsbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight associated to output least significant bit</dd>
<dt> <code class="parametername">constant</code>  (<code class="parametertype">string</code>) </dt><dd>constant given in arbitrary-precision decimal, or as a Sollya expression, e.g "log(2)"</dd>
<span class="optionalparam"> <dt> <code class="parametername">targetUlpError</code>  (<code class="parametertype">real</code>)   (optional, default value is 1.0)</dt><dd>required precision on last bit. Should be strictly greater than 0.5 and lesser than 1</dd> </span>
</dl></dd>
<dd>This variant of Ken Chapman's Multiplier is briefly described in <a href="bib/flopoco.html#DinIstoMas2014-SOPCJR">this article</a>.<br> Special constants, such as 0 or powers of two, are handled efficiently.</dd>
</dl>
<dl>
<dt class="operatorname">FixComplexKCM</dt>
<dd class="operatordescription">Table-based complex multiplier. Inputs are two's complement. Output size is computed</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">msbIn</code>  (<code class="parametertype">int</code>) </dt><dd>weight associated to most significant bit (including sign bit)</dd>
<dt> <code class="parametername">lsbIn</code>  (<code class="parametertype">int</code>) </dt><dd>weight associated to least significant bit</dd>
<dt> <code class="parametername">lsbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight associated to output least significant bit</dd>
<dt> <code class="parametername">constantRe</code>  (<code class="parametertype">string</code>) </dt><dd>real part of the constant, given as a Sollya expression, e.g "log(2)"</dd>
<dt> <code class="parametername">constantIm</code>  (<code class="parametertype">string</code>) </dt><dd>imaginary part of the constant, given as a Sollya expression, e.g "log(2)"</dd>
</dl></dd>
</dl>
<h3>Composite floating-point operators</h3>
<dl>
<dt class="operatorname">FPLargeAcc</dt>
<dd class="operatordescription">Accumulator of floating-point numbers into a large fixed-point accumulator. CURRENTLY BROKEN, contact us if you want to use it</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wEX</code>  (<code class="parametertype">int</code>) </dt><dd>the width of the exponent </dd>
<dt> <code class="parametername">wFX</code>  (<code class="parametertype">int</code>) </dt><dd>the width of the fractional part</dd>
<dt> <code class="parametername">MaxMSBX</code>  (<code class="parametertype">int</code>) </dt><dd>the weight of the MSB of the expected exponent of X</dd>
<dt> <code class="parametername">MSBA</code>  (<code class="parametertype">int</code>) </dt><dd>the weight of the least significand bit of the accumulator</dd>
<dt> <code class="parametername">LSBA</code>  (<code class="parametertype">int</code>) </dt><dd>the weight of the most significand bit of the accumulator</dd>
</dl></dd>
<dd>Kulisch-like accumulator of floating-point numbers into a large fixed-point accumulator. By tuning the MaxMSB_in, LSB_acc and MSB_acc parameters to a given application, rounding error may be reduced to a provably arbitrarily low level, at a very small hardware cost compared to using a floating-point adder for accumulation. <br> For details on the technique used and an example of application, see <a href="bib/flopoco.html#DinechinPascaCret2008:FPT">this article</a></dd>
</dl>
<dl>
<dt class="operatorname">LargeAccToFP</dt>
<dd class="operatordescription">Post-normalisation unit for FPLargeAcc.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE_out</code>  (<code class="parametertype">int</code>) </dt><dd>the width of the output exponent </dd>
<dt> <code class="parametername">wF_out</code>  (<code class="parametertype">int</code>) </dt><dd>the width of the output fractional part</dd>
<dt> <code class="parametername">MSBA</code>  (<code class="parametertype">int</code>) </dt><dd>the weight of the most significand bit of the accumulator</dd>
<dt> <code class="parametername">LSBA</code>  (<code class="parametertype">int</code>) </dt><dd>the weight of the least significand bit of the accumulator</dd>
</dl></dd>
<dd>Converts the (fixed-point) output of FPLargeAcc or FPDotProduct (with the same parameters) into a floating-point number.  <br> For details on the technique used and an example of application, see <a href="bib/flopoco.html#DinechinPascaCret2008:FPT">this article</a></dd>
</dl>
<dl>
<dt class="operatorname">FPDotProduct</dt>
<dd class="operatordescription">Floating-point dot product unit based on FPLargeAcc</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>the width of the exponent for the inputs X and Y</dd>
<dt> <code class="parametername">wFX</code>  (<code class="parametertype">int</code>) </dt><dd>the width of the fraction for the input X</dd>
<dt> <code class="parametername">wFY</code>  (<code class="parametertype">int</code>) </dt><dd>the width of the fraction for the input Y</dd>
<dt> <code class="parametername">MaxMSBX</code>  (<code class="parametertype">int</code>) </dt><dd>maximum expected weight of the MSB of the summand</dd>
<dt> <code class="parametername">MSBA</code>  (<code class="parametertype">int</code>) </dt><dd>The weight of the LSB of the accumulator determines the final accuracy of the result</dd>
<dt> <code class="parametername">LSBA</code>  (<code class="parametertype">int</code>) </dt><dd>The weight of the MSB of the accumulator has to greater than that of the maximal expected result</dd>
</dl></dd>
<dd>Kulisch-like dot product operator. It feeds a long accumulator with the unrounded result of a floating-point multiplier, thus removing rounding errors from the multiplication as well. </dd>
</dl>
<h3>Composite fixed-point operators</h3>
<h3>Elementary functions in fixed- or floating-Point</h3>
<dl>
<dt class="operatorname">FPExp</dt>
<dd class="operatordescription">A faithful floating-point exponential function.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
<span class="optionalparam"> <dt> <code class="parametername">d</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>degree of the polynomial. 0 choses a sensible default.</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">k</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>input size to the range reduction table, should be between 5 and 15. 0 choses a sensible default.</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">g</code>  (<code class="parametertype">int</code>)   (optional, default value is -1)</dt><dd>number of guard bits</dd> </span>
</dl></dd>
<dd>Parameter d and k control the DSP/RamBlock tradeoff. In both cases, a value of 0 choses a sensible default. Parameter g is mostly for internal use.<br> For all the details, see <a href="bib/flopoco.html#DinechinPasca2010-FPT">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FPLog</dt>
<dd class="operatordescription">Floating-point logarithm using an iterative method.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits</dd>
<span class="optionalparam"> <dt> <code class="parametername">inTableSize</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>The input size to the tables, in bits, between 6 and 16. 0 choses a a sensible value</dd> </span>
</dl></dd>
<dd>For details on the technique used, see <a href="bib/flopoco.html#DetDinPuj2007:Arith">this article</a> and <a href="bib/flopoco.html#2010-RR-FPLog">this research report</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FPPow</dt>
<dd class="operatordescription">A floating-point power function.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>exponent size in bits for both inputs</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>mantissa size in bits for both inputs</dd>
<span class="optionalparam"> <dt> <code class="parametername">logSizeTable</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>The table size input for the log in bits</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">type</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>type of power function (0 pow - 1 powr. See IEEE754-2008)</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">expTableSize</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>The table size input for the exponent in bit</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">expDegree</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd></dd> </span>
</dl></dd>
<dd>For all the details, see <a href="bib/flopoco.html#DinechinEtAl-2013-power">this article</dd>
</dl>
<dl>
<dt class="operatorname">FixSinCos</dt>
<dd class="operatordescription">Computes (1-2^(-w)) sin(pi*x) and (1-2^(-w)) cos(pi*x) for x in -[1,1[, using tables and multipliers.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">lsb</code>  (<code class="parametertype">int</code>) </dt><dd>weight of the LSB of the input and outputs</dd>
</dl></dd>
<dd>For a fixed-point 2's complement input x in [-1,1[, calculates (1-2^(lsbIn))*{sin,cos}(pi*x) using a table- and multiplier-based technique. <br>For more details, see <a href="bib/flopoco.html#DinIstSer2013-HEART-SinCos">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">CordicSinCos</dt>
<dd class="operatordescription">Computes (1-2^(-w)) sin(pi*x) and (1-2^(-w)) cos(pi*x) for x in -[1,1[, using CORDIC algorithm</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">lsb</code>  (<code class="parametertype">int</code>) </dt><dd>weight of the LSB of the input and outputs</dd>
<span class="optionalparam"> <dt> <code class="parametername">reducedIterations</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>If 1, number of iterations will be reduced at the cost of two multiplications. </dd> </span>
</dl></dd>
<dd>This is a classical CORDIC, implemented the FloPoCo way: it is last-bit accurate, hopefully at the minimum cost. <br>For more details, see <a href="bib/flopoco.html#DinIstSer2013-HEART-SinCos">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FixAtan2</dt>
<dd class="operatordescription">Computes atan(x/y) as a=(angle in radian)/pi so a in [-1,1[.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">lsb</code>  (<code class="parametertype">int</code>) </dt><dd>weight of the LSB of both inputs and outputs</dd>
<dt> <code class="parametername">method</code>  (<code class="parametertype">int</code>) </dt><dd>parameter select between: InvMultAtan with approximations of the corresponding degree (0..7), plain CORDIC (8), CORDIC with scaling (9), a method using surface approximation (10), Taylor approximation of order 1 (11) and 2 (12)</dd>
</dl></dd>
<dd>For more details, see <a href="bib/flopoco.html#DinIsto2015">this article</a>.</dd>
</dl>
<h3>Arbitrary function approximators</h3>
<dl>
<dt class="operatorname">FixFunctionByTable</dt>
<dd class="operatordescription">Evaluator of function f on [0,1) or [-1,1), depending on signedIn, using a table.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">f</code>  (<code class="parametertype">string</code>) </dt><dd>function to be evaluated between double-quotes, for instance "exp(x*x)"</dd>
<dt> <code class="parametername">signedIn</code>  (<code class="parametertype">bool</code>) </dt><dd>true if the function input is [-1,1), false if it is [0,1)</dd>
<dt> <code class="parametername">lsbIn</code>  (<code class="parametertype">int</code>) </dt><dd>weight of input LSB, for instance -8 for an 8-bit input</dd>
<dt> <code class="parametername">msbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight of output MSB</dd>
<dt> <code class="parametername">lsbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight of output LSB</dd>
</dl></dd>
<dd>This operator uses a table to store function values.</dd>
</dl>
<dl>
<dt class="operatorname">FixFunctionBySimplePoly</dt>
<dd class="operatordescription">Evaluator of function f on [0,1) or [-1,1), using a single polynomial with Horner scheme</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">f</code>  (<code class="parametertype">string</code>) </dt><dd>function to be evaluated between double-quotes, for instance "exp(x*x)"</dd>
<dt> <code class="parametername">lsbIn</code>  (<code class="parametertype">int</code>) </dt><dd>weight of input LSB, for instance -8 for an 8-bit input</dd>
<dt> <code class="parametername">msbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight of output MSB</dd>
<dt> <code class="parametername">lsbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight of output LSB</dd>
<span class="optionalparam"> <dt> <code class="parametername">signedIn</code>  (<code class="parametertype">bool</code>)   (optional, default value is true)</dt><dd>defines the input range : [0,1) if false, and [-1,1) otherwise</dd> </span>
</dl></dd>
<dd>This operator uses a table for coefficients, and Horner evaluation with truncated multipliers sized just right.<br>For more details, see <a href="bib/flopoco.html#DinJolPas2010-poly">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FixFunctionByPiecewisePoly</dt>
<dd class="operatordescription">Evaluator of function f on [0,1), using a piecewise polynomial of degree d with Horner scheme.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">f</code>  (<code class="parametertype">string</code>) </dt><dd>function to be evaluated between double-quotes, for instance "exp(x*x)"</dd>
<dt> <code class="parametername">lsbIn</code>  (<code class="parametertype">int</code>) </dt><dd>weight of input LSB, for instance -8 for an 8-bit input</dd>
<dt> <code class="parametername">msbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight of output MSB</dd>
<dt> <code class="parametername">lsbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight of output LSB</dd>
<dt> <code class="parametername">d</code>  (<code class="parametertype">int</code>) </dt><dd>degree of the polynomial</dd>
<span class="optionalparam"> <dt> <code class="parametername">approxErrorBudget</code>  (<code class="parametertype">real</code>)   (optional, default value is 0.25)</dt><dd>error budget in ulp for the approximation, between 0 and 0.5</dd> </span>
</dl></dd>
<dd>This operator uses a table for coefficients, and Horner evaluation with truncated multipliers sized just right.<br>For more details, see <a href="bib/flopoco.html#DinJolPas2010-poly">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FixFunctionByMultipartiteTable</dt>
<dd class="operatordescription">A function evaluator using the multipartite method.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">f</code>  (<code class="parametertype">string</code>) </dt><dd>function to be evaluated between double-quotes, for instance "exp(x*x)"</dd>
<dt> <code class="parametername">nbTables</code>  (<code class="parametertype">int</code>) </dt><dd>the number of tables used to decompose the function, between 2 (bipartite) to 4 or 5 for large input sizes</dd>
<dt> <code class="parametername">lsbIn</code>  (<code class="parametertype">int</code>) </dt><dd>weight of input LSB, for instance -8 for an 8-bit input</dd>
<dt> <code class="parametername">msbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight of output MSB</dd>
<dt> <code class="parametername">lsbOut</code>  (<code class="parametertype">int</code>) </dt><dd>weight of output LSB</dd>
<span class="optionalparam"> <dt> <code class="parametername">signedIn</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>defines the input range : [0,1) if false, and [-1,1) otherwise</dd> </span>
</dl></dd>
<dd>This operator uses the multipartite table method as introduced in <a href="http://perso.citi-lab.fr/fdedinec/recherche/publis/2005-TC-Multipartite.pdf">this article</a>, with the improvement described in <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6998028&tag=1">this article</a>. </dd>
</dl>
<dl>
<dt class="operatorname">BasicPolyApprox</dt>
<dd class="operatordescription">Helper/Debug feature, does not generate VHDL. Polynomial approximation of function f, accurate to targetAcc on [0,1)</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">f</code>  (<code class="parametertype">string</code>) </dt><dd>function to be evaluated between double-quotes, for instance "exp(x*x)"</dd>
<dt> <code class="parametername">targetAcc</code>  (<code class="parametertype">real</code>) </dt><dd>the target approximation errror of the polynomial WRT the function</dd>
<span class="optionalparam"> <dt> <code class="parametername">signedIn</code>  (<code class="parametertype">bool</code>)   (optional, default value is true)</dt><dd>defines the input range : [0,1) if false, and [-1,1) otherwise</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">g</code>  (<code class="parametertype">int</code>)   (optional, default value is -1)</dt><dd>the number of guardbits added. Using -1 gives sensible default</dd> </span>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">PiecewisePolyApprox</dt>
<dd class="operatordescription">Helper/Debug feature, does not generate VHDL. Uniformly segmented piecewise polynomial approximation of function f, accurate to targetAcc on [0,1)</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">f</code>  (<code class="parametertype">string</code>) </dt><dd>function to be evaluated between double-quotes, for instance "exp(x*x)"</dd>
<dt> <code class="parametername">targetAcc</code>  (<code class="parametertype">real</code>) </dt><dd>the target approximation errror of the polynomial WRT the function</dd>
<dt> <code class="parametername">d</code>  (<code class="parametertype">int</code>) </dt><dd>the degree to use</dd>
</dl></dd>
</dl>
<h3>Conversions between number systems</h3>
<dl>
<dt class="operatorname">Fix2FP</dt>
<dd class="operatordescription">Conversion from FloPoCo floating-point to fixed-point.</dd>
<dd><em>Parameters:</em> <dl>
<span class="optionalparam"> <dt> <code class="parametername">signed</code>  (<code class="parametertype">bool</code>)   (optional, default value is true)</dt><dd>can be false if all numbers will be positive</dd> </span>
<dt> <code class="parametername">MSB</code>  (<code class="parametertype">int</code>) </dt><dd>weight of the MSB of the output</dd>
<dt> <code class="parametername">LSB</code>  (<code class="parametertype">int</code>) </dt><dd>weight of LSB of the input</dd>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>output exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>output mantissa size in bits</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">FP2Fix</dt>
<dd class="operatordescription">Conversion from FloPoCo floating-point to fixed-point.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wE</code>  (<code class="parametertype">int</code>) </dt><dd>input exponent size in bits</dd>
<dt> <code class="parametername">wF</code>  (<code class="parametertype">int</code>) </dt><dd>input mantissa size in bits</dd>
<span class="optionalparam"> <dt> <code class="parametername">signed</code>  (<code class="parametertype">bool</code>)   (optional, default value is true)</dt><dd>can be false if all numbers will be positive</dd> </span>
<dt> <code class="parametername">MSB</code>  (<code class="parametertype">int</code>) </dt><dd>weight of the MSB of the output</dd>
<dt> <code class="parametername">LSB</code>  (<code class="parametertype">int</code>) </dt><dd>weight of LSB of the output</dd>
<span class="optionalparam"> <dt> <code class="parametername">trunc</code>  (<code class="parametertype">bool</code>)   (optional, default value is true)</dt><dd>true means truncated (cheaper), false means rounded</dd> </span>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">InputIEEE</dt>
<dd class="operatordescription">Conversion from IEEE-754-like to FloPoCo floating-point formats. Subnormals are all flushed to zero at the moment.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wEIn</code>  (<code class="parametertype">int</code>) </dt><dd>input exponent size in bits</dd>
<dt> <code class="parametername">wFIn</code>  (<code class="parametertype">int</code>) </dt><dd>input mantissa size in bits</dd>
<dt> <code class="parametername">wEOut</code>  (<code class="parametertype">int</code>) </dt><dd>output exponent size in bits</dd>
<dt> <code class="parametername">wFOut</code>  (<code class="parametertype">int</code>) </dt><dd>output mantissa size in bits</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">OutputIEEE</dt>
<dd class="operatordescription">Conversion from FloPoCo to IEEE-754-like floating-point formats.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">wEIn</code>  (<code class="parametertype">int</code>) </dt><dd>input exponent size in bits</dd>
<dt> <code class="parametername">wFIn</code>  (<code class="parametertype">int</code>) </dt><dd>input mantissa size in bits</dd>
<dt> <code class="parametername">wEOut</code>  (<code class="parametertype">int</code>) </dt><dd>output exponent size in bits</dd>
<dt> <code class="parametername">wFOut</code>  (<code class="parametertype">int</code>) </dt><dd>output mantissa size in bits</dd>
<span class="optionalparam"> <dt> <code class="parametername">onlyPositiveZeroes</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>when true, normalize +0 and -0 to +0</dd> </span>
</dl></dd>
</dl>
<h3>Filters and FFTs</h3>
<dl>
<dt class="operatorname">FixFIR</dt>
<dd class="operatordescription">A fix-point Finite Impulse Filter generator.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">lsbInOut</code>  (<code class="parametertype">int</code>) </dt><dd>integer size in bits</dd>
<span class="optionalparam"> <dt> <code class="parametername">rescale</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>If true, divides all coefficient by 1/sum(|coeff|)</dd> </span>
<dt> <code class="parametername">coeff</code>  (<code class="parametertype">string</code>) </dt><dd>colon-separated list of real coefficients using Sollya syntax. Example: coeff="1.234567890123:sin(3*pi/8)"</dd>
</dl></dd>
<dd>For more details, see <a href="bib/flopoco.html#DinIstoMas2014-SOPCJR">this article</a>.</dd>
</dl>
<dl>
<dt class="operatorname">FixSOPC</dt>
<dd class="operatordescription">A fix-point Sum of Product by Constants.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">lsbIn</code>  (<code class="parametertype">int</code>) </dt><dd>input's last significant bit</dd>
<dt> <code class="parametername">lsbOut</code>  (<code class="parametertype">int</code>) </dt><dd>output's last significant bit</dd>
<dt> <code class="parametername">coeff</code>  (<code class="parametertype">string</code>) </dt><dd>colon-separated list of real coefficients using Sollya syntax. Example: coeff="1.234567890123:sin(3*pi/8)"</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">FixIIR</dt>
<dd class="operatordescription">A fix-point Infinite Impulse Response filter generator.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">lsbIn</code>  (<code class="parametertype">int</code>) </dt><dd>input most significant bit</dd>
<dt> <code class="parametername">lsbOut</code>  (<code class="parametertype">int</code>) </dt><dd>output least significant bit</dd>
<span class="optionalparam"> <dt> <code class="parametername">H</code>  (<code class="parametertype">real</code>)   (optional, default value is 0)</dt><dd>worst-case peak gain. if 0, it will be computed by the WCPG library</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">Heps</code>  (<code class="parametertype">real</code>)   (optional, default value is 0)</dt><dd>worst-case peak gain of the feedback loop. if 0, it will be computed by the WCPG library</dd> </span>
<dt> <code class="parametername">coeffa</code>  (<code class="parametertype">string</code>) </dt><dd>colon-separated list of real coefficients using Sollya syntax. Example: coeffa="1.234567890123:sin(3*pi/8)"</dd>
<dt> <code class="parametername">coeffb</code>  (<code class="parametertype">string</code>) </dt><dd>colon-separated list of real coefficients using Sollya syntax. Example: coeffb="1.234567890123:sin(3*pi/8)"</dd>
</dl></dd>
</dl>
<h3>Test Benches</h3>
<dl>
<dt class="operatorname">TestBench</dt>
<dd class="operatordescription">Behavorial test bench for the preceding operator.</dd>
<dd><em>Parameters:</em> <dl>
<span class="optionalparam"> <dt> <code class="parametername">n</code>  (<code class="parametertype">int</code>)   (optional, default value is -2)</dt><dd>number of random tests. If n=-2, an exhaustive test is generated (use only for small operators)</dd> </span>
<span class="optionalparam"> <dt> <code class="parametername">file</code>  (<code class="parametertype">bool</code>)   (optional, default value is true)</dt><dd>Inputs and outputs are stored in file test.input (lower VHDL compilation time). If false, they are stored in the VHDL</dd> </span>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">Wrapper</dt>
<dd class="operatordescription">Wraps the preceding operator between registers (for frequency testing).</dd>
<dd><em>Parameters:</em> <dl>
</dl></dd>
</dl>
<h3>AutoTest</h3>
<dl>
<dt class="operatorname">AutoTest</dt>
<dd class="operatordescription">A tester for operators.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">Operator</code>  (<code class="parametertype">string</code>) </dt><dd>name of the operator to test, All if we need to test all the operators</dd>
<span class="optionalparam"> <dt> <code class="parametername">Dependences</code>  (<code class="parametertype">bool</code>)   (optional, default value is false)</dt><dd>test the operator's dependences</dd> </span>
</dl></dd>
</dl>
<h3>Miscellaneous</h3>
<dl>
<dt class="operatorname">NbBitsMin</dt>
<dd class="operatordescription">A tool for FPDiv to compute where to truncate both partial remainder and divider.</dd>
<dd><em>Parameters:</em> <dl>
<dt> <code class="parametername">radix</code>  (<code class="parametertype">int</code>) </dt><dd>It has to be 2^n</dd>
<dt> <code class="parametername">digitSet</code>  (<code class="parametertype">int</code>) </dt><dd>the range you allow for each digit [-digitSet, digitSet]</dd>
</dl></dd>
</dl>
<dl>
<dt class="operatorname">TargetModel</dt>
<dd class="operatordescription">A dummy operator useful when designing a new Target</dd>
<dd><em>Parameters:</em> <dl>
<span class="optionalparam"> <dt> <code class="parametername">type</code>  (<code class="parametertype">int</code>)   (optional, default value is 0)</dt><dd>when 0, build an adder of size 32</dd> </span>
</dl></dd>
<dd>This operator is for FloPoCo developers only. <br> Synthesize this operator, then look at its critical path. <br> Also see Target.hpp.</dd>
</dl>
<dl>
<dt class="operatorname">UserDefinedOperator</dt>
<dd class="operatordescription">An heavily commented example operator to start with FloPoCo.</dd>
<dd><em>Parameters:</em> <dl>
<span class="optionalparam"> <dt> <code class="parametername">param0</code>  (<code class="parametertype">int</code>)   (optional, default value is 16)</dt><dd>A first parameter, here used as the input size</dd> </span>
<dt> <code class="parametername">param1</code>  (<code class="parametertype">int</code>) </dt><dd>A second parameter, here used as the output size</dd>
</dl></dd>
<dd>Feel free to experiment with its code, it will not break anything in FloPoCo. <br> Also see the developper manual in the doc/ directory of FloPoCo.</dd>
</dl>
</body>
</html>
